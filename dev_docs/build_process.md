# Software Build Process & Development Workflow

This document outlines the proposed build process, development workflow, and architectural structure for the **CommuGraph** project, based on the requirements in `requirement_use_cases.md` and `UI_design.md`.

## 1. Architecture Overview

Given the requirements for a "Process Mining" workbench with high-fidelity visualization (React/React Flow) and heavy data processing/LLM integration (Python), the project will be structured as a **Hybrid Monorepo**.

- **Frontend:** Single-Page Application (SPA) responsible for visualization, user interaction, and state management.
- **Backend:** API Server responsible for data ingestion, graph mining logic, anomaly detection, and LLM orchestration.

## 2. Technology Stack Recommendations

### Frontend (The "Dashboard")
- **Framework:** React.js (v18+)
- **Build Tool:** Vite (chosen for speed and optimal dev experience)
- **Language:** TypeScript (strictly enforced for type safety across complex graph data structures)
- **Key Libraries:**
    - `reactflow` or `@xyflow/react` (Graph visualization)
    - `recharts` (Timeline/Swimlane visualization)
    - `react-split` (Layout management)
    - `axios` / `tanstack-query` (API communication)
- **Package Manager:** `npm` (standard) or `pnpm` (performance)

### Backend (The "Engine")
- **Framework:** FastAPI (Python). Chosen for:
    - High performance (async support for concurrent LLM requests).
    - Automatic OpenAPI documentation (critical for frontend integration).
    - Native Pydantic support (excellent for data validation of "Process Mining" schemas).
- **Dependency Management:** `poetry` or `uv` (modern Python project management).

## 3. Proposed Directory Structure

```text
CommuGraph/
├── frontend/                 # React Application
│   ├── src/
│   │   ├── components/       # Reusable UI elements
│   │   ├── features/         # Domain-specific modules (Graph, Timeline, Reports)
│   │   ├── hooks/            # Custom React hooks
│   │   ├── api/              # API client and types
│   │   └── App.tsx
│   ├── package.json
│   ├── vite.config.ts
│   └── tsconfig.json
│
├── backend/                  # Python API Server
│   ├── app/
│   │   ├── api/              # Route handlers
│   │   ├── core/             # Config, security, logging
│   │   ├── services/         # Business logic (Miner, AnomalyDetector, LLM)
│   │   ├── schemas/          # Pydantic models (Data contracts)
│   │   └── main.py
│   ├── tests/
│   ├── pyproject.toml        # Python dependencies
│   └── Dockerfile
│
├── dev_docs/                 # Project documentation
├── scripts/                  # Build/Maintenance scripts
└── docker-compose.yml        # Orchestration for local dev
```

## 4. Development Workflow

### Prerequisite
Developers must have `Node.js`, `Python 3.10+`, and `Docker` installed.

### Setup (First time)
```bash
# 1. Install Frontend Dependencies
cd frontend
npm install

# 2. Install Backend Dependencies
cd ../backend
poetry install
```

### Running Locally
We recommend a unified command (via a root usage of `make` or `npm-run-all`) to start both servers.

**Option A: Separate Terminals**
1. **Frontend:** `npm run dev` (Runs Vite server on `localhost:5173`)
2. **Backend:** `poetry run uvicorn app.main:app --reload` (Runs API on `localhost:8000`)

**Option B: Docker Compose**
`docker-compose up` spins up both services with hot-reloading enabled via volume mounts.

## 5. Build Pipeline

### Frontend Build Process
The frontend artifacts are static files (HTML/CSS/JS) generated by Vite.
1. **Linting:** `npm run lint` (ESLint + Prettier)
2. **Type Checking:** `npm run tsc` (Ensure no TypeScript errors)
3. **Testing:** `npm run test` (Vitest for logic tests)
4. **Build:** `npm run build`
    - Output: `/frontend/dist/` directory containing optimized assets.

### Backend Build Process
The backend is packaged as a Docker container or a Python wheel.
1. **Linting:** `ruff check .` (Fast Python linting)
2. **Formatting:** `black .` / `ruff format`
3. **Testing:** `pytest` (Unit and Integration tests)
4. **Packaging:**
    - **Docker:** Build image `commugraph-backend:latest`.
    - **Poetry:** `poetry build` (for distribution if needed).

## 6. Continuous Integration (CI) Strategy

A CI pipeline (e.g., GitHub Actions) should trigger on every Pull Request (PR).

| Stage | Job | Description |
| :--- | :--- | :--- |
| **Quality** | `lint-frontend` | ESLint + Prettier check |
| | `lint-backend` | Ruff + Black check |
| | `type-check` | TypeScript compilation check |
| **Test** | `unit-tests-fe` | Run Vitest (Components/Utils) |
| | `unit-tests-be` | Run Pytest (Mining logic/API) |
| **Integration**| `e2e-test` | (Optional) Playwright tests on a build preview |
| **Build** | `build-artifacts`| Ensure `npm run build` and Docker build succeed |

## 7. Deployment Strategy (Draft)

For the final deployment, an **Nginx** reverse proxy is recommended to serve the Frontend static files and forward `/api` requests to the Backend container.

**Production Container Structure:**
1. **Multi-stage Dockerfile:**
    - Stage 1: Build Frontend (Node.js image) -> `/app/dist`
    - Stage 2: Setup Backend (Python image)
    - Stage 3: Copy `/app/dist` to Backend's specific static file folder OR configure Nginx to serve it.

This ensures a single deployment artifact (One Docker Container) that contains the full application, simplifying distribution.
