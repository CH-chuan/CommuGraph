schema_version: "0.1"
schema_version: "0.2"
schema_name: "delegation_interaction_codebook_baird_maruping_2021"
source:
  paper: "Baird & Maruping (2021) MISQ"
  grounding:
    - "Task attributes: action requirements (cognitive/digital/physical), complexity (uncertainty/interdependence/dynamics), decomposability"
    - "Delegation mechanisms: appraisal, distribution, coordination"
    - "Outcomes: goal attainment, progress, failure"

annotation_unit:
  name: "turn"
  description: >
    A taggable unit built from the raw Claude Code JSONL by grouping records into conversation turns.

    We intentionally ignore record types like file-history-snapshot and queue-operation.

    Unit construction rules (for the intermediate JSONL used for labeling):
      1) assistant_turn: group ALL assistant records that belong to the same model turn
         (same requestId + message.id). Keep assistant text (and optionally thinking) and summarize
         tool execution status within this turn.
      2) user_turn: a user-typed prompt where user.message.content is a string.

    Tool results (user.tool_result blocks) are not emitted as separate units. They are only used to
    compute coarse tool success/failure attached to the assistant_turn. 
    Tool call Task is special, it is calling sub-agent, thus should be treated also as assistant_turn.
  unit_types:
    - assistant_turn
    - user_turn
  id_fields:
    - session_id
    - event_id
    - actor_id

event_id_convention:
  description: >
    Canonical event_id formats for the intermediate JSONL used for labeling.
    The goal is stability + easy joins back to raw records.
  formats:
    assistant_turn:
      pattern: "A:{request_id}:{message_id}"
      required_source_fields: ["message_id"]
      notes:
        - "One per same-agent model turn grouping."
        - "Primary grouping key: (requestId, message.id)."
        - "Fallback grouping key when requestId is absent: (message.id)."
        - "Recommended event_id:"
        - "  - if request_id present: A:{request_id}:{message_id}"
        - "  - else: A::{message_id}  (empty request_id slot)"
    user_turn:
      pattern: "U:{raw_uuid}"
      required_source_fields: ["raw_uuids"]
      notes:
        - "Use the first element of source.raw_uuids as raw_uuid."

actors:
  actor_types:
    - human
    - agent
  role_types:
    - delegator
    - proxy
    - mixed
    - unknown

labeling_rules:
  multi_label: true
  priority_guidance:
    - "If rights/responsibilities shift, include DELEGATION_DECISION (and optionally negotiation/constraints)."
    - "If the episode breaks down a task, include TASK_DECOMPOSITION."
    - "If the episode assigns a decomposed part, include TASK_SUBTASK_DELEGATION."
    - "If monitoring or overriding is present, include COORD_* labels."
  evidence_requirement:
    - "Prefer explicit cues in text/logs (e.g., 'you take over', 'I’ll review', 'stop')."
    - "Tool calls count as evidence for DIGITAL_EXECUTION unless purely observational."

labels:
  # A. Task Structuring & Work Decomposition
  - id: "TASK_DECOMPOSITION"
    name: "Problem decomposition"
    family: "task_structuring"
    definition: "Break a goal/task into smaller components, steps, or phases."
    include_when:
      - "Enumerates subtasks/steps/modules"
      - "Reframes a goal into a structured plan"
    exclude_when:
      - "Actually assigning ownership of a subtask (use TASK_SUBTASK_DELEGATION)"
    cues:
      - "split into"
      - "step 1/2/3"
      - "phases"
      - "modules"
      - "first...then..."
    examples:
      positive:
        - "Let’s split this refactor into parser, graph builder, renderer."
      negative:
        - "Agent B, handle the parser." # subtask delegation
    output_fields:
      optional:
        decomposition:
          type: "list[string]"
          description: "Named subtasks/components if present."

  - id: "TASK_SUBTASK_DELEGATION"
    name: "Subtask delegation"
    family: "task_structuring"
    definition: "Delegate a specific decomposed subtask to another agent/component."
    include_when:
      - "Assigns a subtask owner after decomposition"
      - "Creates/dispatches a sub-agent with a scoped task"
    exclude_when:
      - "General delegation of entire task (use DELEGATION_DECISION without subtask scoping)"
      - "Advice-seeking without transfer (use DELEGATION_APPRAISAL)"
    cues:
      - "you handle"
      - "assign"
      - "delegate this part"
      - "Agent X do"
      - "Task tool spawn"
    examples:
      positive:
        - "Agent B, handle the log parser; Agent C, build the UI."
    output_fields:
      optional:
        assignee_actor_id:
          type: "string"
        subtask_name:
          type: "string"

  # B. Action Execution Types
  - id: "EXEC_COGNITIVE"
    name: "Cognitive execution"
    family: "execution"
    definition: "Reasoning/planning/abstraction/model-building actions."
    include_when:
      - "Designing approach/algorithm/architecture"
      - "Reasoning about edge cases or causal structure"
    exclude_when:
      - "Pure code edits without reasoning content (may still co-occur with EXEC_DIGITAL)"
    cues:
      - "we should"
      - "because"
      - "consider"
      - "tradeoff"
      - "design"
    examples:
      positive:
        - "Because timestamps are async, we need a DAG ordering rule."

  - id: "EXEC_DIGITAL"
    name: "Digital execution"
    family: "execution"
    definition: "Digital actions that change or run computational artifacts (code/config/scripts)."
    include_when:
      - "Writes/edits code or config"
      - "Runs tests/scripts/build"
      - "Tool calls that modify files"
    cues:
      - "implemented"
      - "commit"
      - "run tests"
      - "npm run"
      - "pip install"
    examples:
      positive:
        - "I added a parser function and ran the unit tests."
    output_fields:
      optional:
        tool_name:
          type: "string"
        files_touched:
          type: "list[string]"
        command:
          type: "string"

  # D. Delegation Mechanisms
  - id: "DELEGATION_APPRAISAL"
    name: "Delegation appraisal"
    family: "delegation_appraisal"
    definition: >
      Assess the other party’s competence/fit/reliability for a task (capability + trust + compatibility),
      without yet transferring ownership.
    include_when:
      - "Asks whether the other can do something / is suitable"
      - "Evaluates reliability/risk/safety/accuracy of the other party"
      - "Evaluates alignment/compatibility of approach or preferences"
    exclude_when:
      - "Ownership/authority is transferred (use DELEGATION_DECISION)"
    cues:
      - "can you"
      - "able to"
      - "capable"
      - "best suited"
      - "trust"
      - "reliable"
      - "risk"
      - "safe"
      - "accurate"
      - "align"
      - "compatible"
    examples:
      positive:
        - "Can you handle the DAG reconstruction logic?"

  - id: "DELEGATION_DECISION"
    name: "Delegation decision"
    family: "delegation_distribution"
    definition: "Explicit decision to transfer rights/responsibilities for execution/outcomes."
    include_when:
      - "States transfer of ownership/authority"
    cues:
      - "I’ll let you"
      - "you take over"
      - "delegate"
      - "hand off"
    examples:
      positive:
        - "You take over the refactor."

  - id: "DELEGATION_NEGOTIATION"
    name: "Delegation negotiation / clarification"
    family: "delegation_distribution"
    definition: >
      Back-and-forth needed to proceed: negotiate scope/responsibilities/authority boundaries OR request
      a decision/clarification from the other party that determines how work is delegated/executed.
    include_when:
      - "Conditional delegation"
      - "Negotiates responsibilities/authority boundaries"
      - "Requests a decision/clarification required to proceed"
    cues:
      - "if you"
      - "as long as"
      - "I can do X provided Y"
      - "who will handle"
      - "please confirm"
      - "which do you prefer"
      - "I need clarification"
      - "what is the requirement"
    examples:
      positive:
        - "I can implement this if you confirm the log ordering rule."

  - id: "DELEGATION_CONSTRAINT_SETTING"
    name: "Constraint setting"
    family: "delegation_distribution"
    definition: "Set explicit boundaries/rules to prevent undesired actions/outcomes."
    include_when:
      - "Do not change X"
      - "Must keep compatibility/performance/security"
    cues:
      - "do not"
      - "must"
      - "constraint"
      - "keep backward compatible"
    examples:
      positive:
        - "Do not change the public API; keep existing endpoints."

  # E. Coordination & Oversight
  - id: "COORD_MONITORING"
    name: "Monitoring"
    family: "coordination"
    definition: "Observe delegated execution without altering it."
    include_when:
      - "Requests status/progress"
      - "Reads outputs/logs to check"
    cues:
      - "status?"
      - "show progress"
      - "how’s it going"
      - "let me see logs"

  - id: "COORD_INTERVENTION"
    name: "Intervention"
    family: "coordination"
    definition: "Override/correct direction during delegated execution."
    include_when:
      - "Stops or changes agent actions"
      - "Explicitly reverses a decision"
    cues:
      - "stop"
      - "undo"
      - "don’t do that"
      - "change approach"

  - id: "COORD_STATE_UPDATING"
    name: "State updating"
    family: "coordination"
    definition: "Provide status updates to maintain shared situational awareness."
    include_when:
      - "Reports completion/progress/failure"
      - "Communicates new state or artifacts"
    cues:
      - "done"
      - "completed"
      - "tests passed"
      - "I updated"
    output_fields:
      optional:
        progress_percent:
          type: "number"
        status:
          type: "string"
          enum: ["started", "in_progress", "blocked", "completed", "failed"]

  - id: "COORD_COMMON_UNDERSTANDING"
    name: "Common understanding alignment"
    family: "coordination"
    definition: "Align shared meaning of terms/schemas/goals."
    include_when:
      - "Defines terminology"
      - "Clarifies what counts as success or what a concept means"
    cues:
      - "by X I mean"
      - "define"
      - "clarify"
      - "interpret as"

record_template:
  type: "object"
  required:
    - session_id
    - event_id
    - actor_id
    - actor_type
    - unit_type
    - source
    - text_or_artifact_ref
    - labels
  properties:
    session_id: { type: "string" }
    event_id: { type: "string" }
    actor_id: { type: "string" }
    actor_type: { type: "string", enum: ["human", "agent"] }
    role: { type: "string", enum: ["delegator", "proxy", "mixed", "unknown"] }
    agent_kind:
      type: "string"
      description: "Only for actor_type=agent."
      enum: ["main", "sub", "unknown"]
    unit_type:
      type: "string"
      enum: ["assistant_turn", "user_turn"]
    source:
      type: "object"
      description: >
        Pointers back to raw JSONL for traceability. These fields are meant to be populated in the
        intermediate JSONL (created prior to labeling).
      properties:
        raw_file:
          type: "string"
          description: "Path to the source JSONL file (main or agent-*.jsonl)."
        raw_line_range:
          type: "array"
          description: "[startLine, endLine] in the raw JSONL file if known."
          items: { type: "integer" }
        raw_uuids:
          type: "array"
          description: "One or more raw record uuids contributing to this unit (if present)."
          items: { type: "string" }
        request_id: { type: "string" }
        message_id: { type: "string" }
        tool_use_ids:
          type: "array"
          description: "All tool_use.id values emitted in this assistant turn (if any)."
          items: { type: "string" }
        is_sidechain: { type: "boolean" }
        agent_id: { type: "string" }
    timestamp:
      type: "string"
      description: "Optional. If present, ISO-8601 recommended (e.g., unit start timestamp)."
    tool_summary:
      type: "object"
      description: >
        Coarse summary of tool execution within this assistant turn. Tool results are not annotated as units;
        they only populate this summary for downstream analysis.
      properties:
        tool_calls:
          type: "array"
          items:
            type: "object"
            required: ["tool_use_id", "tool_name"]
            properties:
              tool_use_id: { type: "string" }
              tool_name: { type: "string" }
              success:
                type: "boolean"
                description: "True if tool results indicate success (coarse)."
              is_error:
                type: "boolean"
                description: "True if any matching tool_result has is_error=true."
              result_count: { type: "integer", minimum: 0 }
    text_or_artifact_ref:
      type: "object"
      description: "Reference to message text or tool artifact."
      properties:
        text: { type: "string" }
        tool_call_id: { type: "string" }
        artifact_path: { type: "string" }
    labels:
      type: "array"
      items:
        type: "object"
        required: ["id"]
        properties:
          id: { type: "string" }
          confidence: { type: "number", minimum: 0.0, maximum: 1.0 }
          evidence:
            type: "object"
            properties:
              quote: { type: "string" }
              cue: { type: "string" }
          fields:
            type: "object"
            description: "Label-specific output fields, if any."

validation_checks:
  - id: "unknown_label"
    description: "All label ids must exist in schema labels list."
  - id: "required_fields_present"
    description: "Record contains all required properties."
  - id: "unit_type_required_source_fields"
    description: >
      Minimal source pointers for unit types:
        - assistant_turn should have (request_id, message_id).
        - user_turn should have raw_uuids.